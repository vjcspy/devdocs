# m-o-triggers Overview

## Purpose & Scope
- Hosts the triggers HTTP API and scheduler on top of `TinyDatabaseAppAuthenticated`, wiring Kong authentication, request validators, and Awilix dependency registration inside `createApp`/`App` (`src/cmd/app/main.ts:50`). This entrypoint is what other Tinybots services hit when they need to manage robot trigger settings or fetch trigger state.
- Owns the full trigger lifecycle: create internal triggers, lock and poll `event_trigger` rows, evaluate scheduling windows, and enqueue robot-specific jobs on SQS via the collaboration between `EventTriggersService`, `TriggerSchedulerParser`, and `TriggerSchedulerService` (`src/services/EventTriggersService.ts:43`, `src/services/TriggerSchedulerParser.ts:44`, `src/services/TriggerSchedulersService.ts:120`).
- Keeps scheduling decisions fast and safe by caching event schemas/settings plus refreshing them on Cron schedules (`src/services/EventSchemasService.ts:16`, `src/services/EventTriggerSettingsCacheService.ts:23`). Day-of-week, time-of-day, validity, and concurrency rules are enforced before a trigger is accepted or executed (`src/services/TriggerSchedulerParser.ts:183`).

## HTTP Controllers
- `InternalEventTriggersController` exposes `POST /internal/v1/triggers/triggers` for trusted services to create triggers after DTO validation, delegating all logic to the service layer (`src/controllers/InternalEvenTriggersController.ts:6`, `src/cmd/app/main.ts:247`). Integration tests cover schedule recalculation scenarios (weekday gaps, robot-specific defaults) in `test/controllers/InternalEventTriggersControllerIT.ts:1`.
- `EventTriggersController` powers `GET /v1/triggers/triggers/:triggerId`, authenticates robots via Kong headers, and only returns triggers that belong to the logged-in robot and have not expired/failed (`src/controllers/EventTriggersController.ts:7`, `src/cmd/app/main.ts:253`). The IT suite asserts robot scoping, TTL-based hiding, and schedule constraints in `test/controllers/EventTriggersControllerIT.ts:1`.
- `EventTriggerSettingsController` handles `PUT /v1/triggers/settings` for admins with `M_O_TRIGGERS_SETTING_WRITE_ALL`, parsing human-friendly strings (HH:mm, `10m`, weekdays) via `UpsertTriggerSettingDto` before upserting defaults/robot overrides (`src/controllers/EventTriggerSettingsController.ts:6`, `src/models/dtos/UpsertTriggerSettingDto.ts:1`, `src/cmd/app/main.ts:261`). Validation and DB persistence paths are exercised in `test/controllers/EventTriggerSettingControllerIT.ts:1`.

## Core Services & Flow
- **EventTriggersService** orchestrates trigger creation, robot-scoped retrieval, TTL-based failure handling, and trigger-setting upserts (`src/services/EventTriggersService.ts:43`). It immediately schedules freshly created triggers by loading their settings from cache and asking the scheduler to prepare/execute them (`src/services/EventTriggersService.ts:136`). Robot-facing reads ensure the trigger belongs to the caller and is neither failed nor expired beyond `maxTriggerTTL` (`src/services/EventTriggersService.ts:84`, `src/services/EventTriggersService.ts:203`).
- **TriggerSchedulerService** is the heart of execution: it uses a `TimerPool`, Cron jobs, and SQS producers to acquire ready triggers, preload their settings, run parser validations, enqueue timers, and finally emit robot-specific messages to `${baseRobotQueueAddress}${robotId}` (`src/services/TriggerSchedulersService.ts:120`, `src/services/TriggerSchedulersService.ts:146`, `src/services/TriggerSchedulersService.ts:287`, `src/services/TriggerSchedulersService.ts:371`, `src/services/TriggerSchedulersService.ts:424`). It also unlocks stuck triggers with periodic cleanup jobs.
- **TriggerSchedulerParser** encapsulates the rules engine. `pre` finds the applicable default or robot-specific setting and computes the first allowed execution slot; `post`/`execute` decide whether the trigger can start now/next cycle and enforce max concurrency windows via transactional counts (`src/services/TriggerSchedulerParser.ts:44`, `src/services/TriggerSchedulerParser.ts:95`, `src/services/TriggerSchedulerParser.ts:183`). Day-of-week rescheduling and validity checks live in `getExpectedExecutedTime` and helper functions (`src/services/TriggerSchedulerParser.ts:241`).
- **EventTriggerSettingsCacheService** wraps a TTL cache to reduce DB reads when the scheduler needs settings. It lazily loads or bulk preloads setting IDs pulled from locked triggers so scheduling remains cheap (`src/services/EventTriggerSettingsCacheService.ts:23`, `src/services/EventTriggerSettingsCacheService.ts:36`, `src/services/EventTriggerSettingsCacheService.ts:55`).
- **EventSchemasService** maintains an in-memory map of `event_schema` rows, refreshing it on a Cron interval so setting upserts can resolve `eventName` → `eventTypeId` without DB fan-out (`src/services/EventSchemasService.ts:16`, `src/services/EventSchemasService.ts:50`).

## Data & Persistence
- `EventTriggersRepository` encapsulates all SQL for `event_trigger` and `event_trigger_setting`: creating references, stamping defaults, locking/unlocking rows, recovering orphans, counting executed triggers for concurrency checks, and updating statuses atomically via prepared statements and transactions (`src/repositories/EventTriggerRepository.ts:12`, `src/repositories/EventTriggerRepository.ts:139`, `src/repositories/EventTriggerRepository.ts:351`, `src/repositories/EventTriggerRepository.ts:527`). The scheduler relies on these methods to safely acquire and execute work.
- `EventSchemasRepository` holds a dedicated MySQL connection plus a prepared query to fetch schemas updated since a timestamp, feeding the schema cache (`src/repositories/EventSchemasRepository.ts:29`).
- Domain models under `src/models/domains` provide serialization/validation helpers, including day-of-week (de)serialization and HH:mm formatting for API responses (`src/models/domains/EventTriggerDomain.ts:1`).

## External & Neighboring Systems
- The service leans heavily on the shared `tiny-backend-tools` repo for Express scaffolding, context/callRef propagation, Cron utilities, SQS producers, repository base classes, and permission validators (`src/cmd/app/main.ts:1`). `PermissionAPIProvider` lets it call the centralized permissions service using configuration loaded at boot (`src/cmd/app/main.ts:149`).
- Kong (`kong-js`) supplies robot/dashboard user identities for request validation and SSO headers (`src/cmd/app/main.ts:4`, `src/controllers/EventTriggersController.ts:2`).
- Trigger execution pushes messages onto AWS SQS queues whose names are derived from the robot ID; the queue address prefix and limits come from the scheduler config (`src/services/TriggerSchedulersService.ts:146`, `src/models/SchedulerConfig.ts:1`).
- MySQL (the Tinybots operational database) stores `event_schema`, `event_trigger_setting`, and `event_trigger` tables accessed through the repositories’ SQL (`src/repositories/EventTriggerRepository.ts:147`). Integration tests seed/clean those tables via helpers built on the shared `tiny-testing` repo (`test/helpers/DbSetup.ts:1`).

## Tests & How To Explore Behavior
- The controller IT suites demonstrate end-to-end flows against a real DB: fetching triggers with robot scoping (`test/controllers/EventTriggersControllerIT.ts:1`), admin upserts and validation failures (`test/controllers/EventTriggerSettingControllerIT.ts:1`), and rescheduling behavior across weekdays/time windows (`test/controllers/InternalEventTriggersControllerIT.ts:1`).
- Service-level specs under `test/services` cover caching, schema refresh, scheduler polling, and parser edge cases so you can see expected behavior without spinning up external dependencies.
- `test/helpers/DbSetup.ts:1` shows how the tests talk to the shared Tinybots schema (robots, subscriptions, incoming/outgoing events), which is useful when you need to seed additional fixtures locally.

